===========================================================================================================================================================================

																			i) PROGRAM-01 (water jug)

def water_jug(jug1,jug2,target):
    stack=[(0,0,"Start")]
    visited=set()

    while stack:
        a,b,action=stack.pop()

        print(f"Action : {action} -> Jug1 : {a}L, Jug2 : {b}L")

        if a==target or b==target:
            print(f"Solution found : ({a},{b})")
            return True
    
        if (a,b) in visited:
            continue

        visited.add((a,b))
        
        next_status=[(jug1,b,"Filled Jug1") if (jug1,b) not in visited else None,
                     (a,jug2,"Filled Jug2") if (a,jug2) not in visited else None,
                     (0,b,"Emptied Jug1") if (0,b) not in visited else None,
                     (a,0,"Emptied Jug2") if (a,0) not in visited else None,
                     (a-min(a,jug2-b),b+min(a,jug2-b),"Poured Jug1 -> Jug2") if (a-min(a,jug2-b),b+min(a,jug2-b)) not in visited else None,
                     (a+min(b,jug1-a),b-min(b,jug1-a),"Poured Jug1 -> Jug2") if (a+min(b,jug1-a),b-min(b,jug1-a)) not in visited else None                          
                    ]
        
        stack.extend(filter(None,next_status))

    print("No soultion found")
    return False

water_jug(3,5,4)


============================================================================================================================================================================

																		ii) program-02 (missionaries & cannibels)

from collections import deque

def is_valid(state):
    m_left,c_left,boat,m_right,c_right = state

    if(m_left<0 or c_left<0 or m_right<0 or c_right<0):
        return False
    if(m_left>0 and m_left<c_left) or (m_right>0 and m_right<c_right):
        return False
    
    return True

def succesors(state):
    moves=[(1,0),(2,0),(0,1),(0,2),(1,1)]
    m_left,c_left,boat,m_right,c_right = state
    next_states=[]

    for m,c in moves:
        if boat==1:
            new_state = (m_left-m, c_left -c,0,m_right+m,c_right+c)
        else:
            new_state = (m_left+m,c_left+c,1,m_right-m,c_right-c)
        
        if is_valid(new_state):
            next_states.append(new_state)
    
    return next_states

def bfs(start,goal):
    queue = deque([(start,[start])])
    visited = set()

    while queue:
        state,path = queue.popleft()
        if state == goal:
            return path
        visited.add(state)
        for next_state in succesors(state):
            if next_state not in visited:
                queue.append((next_state,path+[next_state]))

    return None

def solve():
    start = (3, 3, 1, 0, 0)
    goal = (0, 0, 0, 3, 3)
    solution =bfs(start,goal)
    if solution:
        for step in solution:
            print(step)
    else:

        print("No solution found")

solve()

==========================================================================================================================================================================

																				PROGRAM-03 (A* & AO*)

a) A*

from queue import PriorityQueue

def a_star(start, goal, graph, h):
    open_list = PriorityQueue()
    open_list.put((h[start], 0, start))
    came_from = {}
    visited = set()

    while not open_list.empty():
        f, g, node = open_list.get()

        if node == goal:
            print(f"A* path reached goal {goal} with cost {g}")
            return g

        visited.add(node)

        for neighbor, cost in graph[node]:
            if neighbor not in visited:
                g_new = g + cost
                f_new = g_new + h[neighbor]
                open_list.put((f_new, g_new, neighbor))
                came_from[neighbor] = node

# Graph: A → B, C, D (OR paths)
graph_a = {
    'A': [('B', 1), ('C', 2), ('D', 4)],
    'B': [], 'C': [], 'D': []
}
heuristics_a = {'A': 3, 'B': 1, 'C': 2, 'D': 0}

print("A* Cost from A to D:", a_star('A', 'D', graph_a, heuristics_a))

========================================================

b) AO*

def ao_star(node, graph, h):
    if not graph[node]: # If node is terminal, return its heuristic
        return h[node]

    min_cost = float('inf') # Start with high cost
    best_path = None

    for path in graph[node]: # path is a group like ['B', 'C'] or ['D']
        cost = sum(h[n] for n in path)
        if cost < min_cost:
            min_cost = cost
            best_path = path

    h[node] = min_cost # Update heuristic for current node
    print(f"AO* best path from {node}: {best_path} with cost {min_cost}")
    return h[node]

# Graph: A → [B AND C] or [D]
graph_ao = {
    'A': [['B', 'C'], ['D']],
    'B': [], 'C': [], 'D': []
}
heuristics_ao = {'A': 999, 'B': 1, 'C': 2, 'D': 4}

print("AO* Final Cost from A:", ao_star('A', graph_ao, heuristics_ao))

===========================================================================================================================================================================

																						PROGRAM - 04 (8 queens)


N = int(input("ENTER THE NUMBER OF QUEENS: "))

board = [[0] * N for _ in range(N)]

def attack(i, j):

    for k in range(0, N):
        if board[i][k] == 1 or board[k][j] == 1:
            return True

    for k in range(0, N):
        for l in range(0, N):
            if (k + l == i + j) or (k - l == i - j):
                if board[k][l] == 1:
                    return True
    return False

def N_queens(n):
    if n == 0:
        return True
    for i in range(0, N):
        for j in range(0, N):
            if (not attack(i, j)) and (board[i][j] != 1):
                board[i][j] = 1
                if N_queens(n - 1) == True:
                    return True
                board[i][j] = 0
    return False

N_queens(N)

for i in board:
    print(" ".join('Q' if x == 1 else '.' for x in i))


===========================================================================================================================================================================

																						PROGRAM - 05 (tsp)

def travel(graph, start):

    unvisited = [i for i in range(len(graph))]
    unvisited.remove(start)
    current = start
    path = [start]
    total_cost=0

    while unvisited:
        cost,closest = min([(graph[current][j], j) for j in unvisited])
        total_cost +=cost
        current = closest
        path.append(current)
        unvisited.remove(current)
    
    total_cost += graph[current][start]
    path.append(start)

    return path,total_cost

graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]

start = 0

path,total_cost = travel(graph, start)

print("The travelling salesman path is:",path)
print("the cost of the path is:",total_cost)


===========================================================================================================================================================================

																						PROGRAM-06 (forward-backward)

6.
from collections import deque

def forward_chain(start, facts):
    seen, q, out = set(start), deque(start), []
    while q:
        c = q.popleft()
        for a, b in facts:
            if a == c and b not in seen:
                out.append([a, b])
                seen.add(b)
                q.append(b)
    return out

# Example fact base (cause-effect pairs)
facts = [
    ('snake', 'reptile'),
    ('reptile', 'animal'),
    ('animal', 'living'),
    ('cat', 'animal'),
    ('apple', 'fruit')
]

result = forward_chain(['snake'], facts)
print(result)


==========================================================================================================================================================================

																						PROGRAM-07 (FOPL)

import re

def dnf(formula):
    formula = formula.strip().strip("()")
    if re.fullmatch(r'[A-Z]|~[A-Z]', formula):
        return formula

    if 'and' in formula or 'or' in formula:
        parts = re.split(r'\sor\s|\sand\s', formula)
        print(f"parts: {parts}")
        dnf_parts = [dnf(part.strip()) for part in parts]
        print(f"dnf_parts: {dnf_parts}")
        
        if 'or' in formula:
            return " or ".join(dnf_parts)
        elif 'and' in formula:
            return " and ".join(dnf_parts)

def cnf(formula):
    formula = formula.strip().strip("()")
    if re.fullmatch(r'[A-Z]|~[A-Z]', formula):
        return formula
    
    if 'and' in formula or 'or' in formula:
        parts = re.split(r'\sor\s|\sand\s', formula)
        cnf_parts = [cnf(part.strip()) for part in parts]
        if 'and' in formula:
            return " and ".join(cnf_parts)
        elif 'or' in formula:
            return " or ".join(cnf_parts)

# Example usage
formula = "(A and B) or C or D"
cnf_formula = cnf(formula)
dnf_formula = dnf(formula)

print("\nFinal CNF:", cnf_formula)
print("Final DNF:", dnf_formula)


===========================================================================================================================================================================

																						PROGRAM-08

import random 

secret = random.randint(1,10)
print("Welcome to the Number Guessing Game ")
print("I am thinking of a number between 1 and 10")

while True : 
    guess = input("Enter a no : ")
    if not guess.isdigit():
        print("Please Guess a no")
        continue
    guess=int(guess)

    if guess<secret:
        print("Too low. Try again.")
    elif guess>secret:
        print("Too high. Try again.")
    else : 
        print("You guessing it again")
        break

===========================================================================================================================================================================
